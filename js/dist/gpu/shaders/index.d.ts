/**
 * WebGPU Shader Sources
 *
 * Shaders are embedded as strings for portability.
 *
 * @module gpu/shaders
 */
export declare const TERNARY_MATMUL_SHADER = "/**\n * Ternary Matrix Multiplication Compute Shader\n *\n * Performs Y = X * W^T * scales where W is ternary-quantized (2 bits per weight).\n *\n * Weight encoding (2 bits each, 4 weights per byte):\n *   0b00 = 0\n *   0b01 = +1\n *   0b10 = -1\n *\n * Memory layout:\n *   - input: [M, K] row-major (M = seqLen, K = inFeatures)\n *   - weights_packed: [N, K_bytes] where K_bytes is ALIGNED to 4 bytes, stored as u32 array\n *   - scales: [N] per-output-channel scales\n *   - output: [M, N] row-major (N = outFeatures)\n *\n * IMPORTANT: K_bytes must be a multiple of 4 for correct u32 indexing.\n * The host code pads weights if necessary.\n */\n\nstruct Uniforms {\n    M: u32,         // Number of input rows (seqLen)\n    N: u32,         // Number of output features\n    K: u32,         // Number of input features (actual, not padded)\n    K_bytes: u32,   // Aligned to multiple of 4: ceil(ceil(K/4) / 4) * 4\n}\n\n@group(0) @binding(0) var<storage, read> input: array<f32>;\n@group(0) @binding(1) var<storage, read> weights_packed: array<u32>;\n@group(0) @binding(2) var<storage, read> scales: array<f32>;\n@group(0) @binding(3) var<storage, read_write> output: array<f32>;\n@group(0) @binding(4) var<uniform> uniforms: Uniforms;\n\n// Decode 2-bit ternary code to float\nfn decode_ternary(code: u32) -> f32 {\n    // 0 = 0, 1 = +1, 2 = -1\n    if (code == 1u) { return 1.0; }\n    if (code == 2u) { return -1.0; }\n    return 0.0;\n}\n\n@compute @workgroup_size(64, 4, 1)\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let row = gid.y;  // Input token index (M dimension)\n    let col = gid.x;  // Output neuron index (N dimension)\n\n    // Bounds check\n    if (row >= uniforms.M || col >= uniforms.N) {\n        return;\n    }\n\n    var acc: f32 = 0.0;\n    let input_offset = row * uniforms.K;\n    let weight_row_offset = col * uniforms.K_bytes;\n\n    // K_bytes is aligned to 4, so we can index directly as u32 array\n    // Each u32 = 4 bytes = 16 ternary weights (4 weights/byte * 4 bytes)\n    let num_u32s = uniforms.K_bytes / 4u;\n\n    for (var u32_idx: u32 = 0u; u32_idx < num_u32s; u32_idx++) {\n        let packed_u32 = weights_packed[weight_row_offset / 4u + u32_idx];\n\n        // Each u32 contains 4 bytes, each byte contains 4 ternary weights\n        for (var byte_in_u32: u32 = 0u; byte_in_u32 < 4u; byte_in_u32++) {\n            let byte_idx = u32_idx * 4u + byte_in_u32;\n            if (byte_idx >= uniforms.K_bytes) { break; }\n\n            // Extract this byte from the u32\n            let byte_val = (packed_u32 >> (byte_in_u32 * 8u)) & 0xFFu;\n\n            // Unpack 4 ternary values from this byte\n            for (var i: u32 = 0u; i < 4u; i++) {\n                let k = byte_idx * 4u + i;\n                if (k >= uniforms.K) { break; }\n\n                let code = (byte_val >> (i * 2u)) & 0x3u;\n                let w = decode_ternary(code);\n                acc += input[input_offset + k] * w;\n            }\n        }\n    }\n\n    // Apply per-channel scale\n    output[row * uniforms.N + col] = acc * scales[col];\n}\n";
//# sourceMappingURL=index.d.ts.map